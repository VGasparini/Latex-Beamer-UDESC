
\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{booktabs}
\usepackage[portuges]{babel}


\title[Uso de Coq para verificação de propriedades de sistemas de tipos]{Uso de Coq para verificação de propriedades de sistemas de tipos}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{22 de Junho de 2018}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\section{Introdução}
\begin{frame}
\frametitle{O que são assistentes de provas?}
\begin{itemize}
    \item Assistentes de provas ou provadores interativos são programas para o desenvolvimento de provas
          formais.
    \item O núcleo de um assistente de provas é um verificador, que verifica a consistência lógica da prova.
    \item Fornecem de maneira interativa de visualizar as informações sobre o estado atual da prova.
    \item A verificação humana de provas é demorada e sujeita a falhas: Último Teorema de Fermat.

      Assistentes de provas permitem provar coisas que não seriam realizáveis somente com papel e caneta!
\end{itemize}
\end{frame}

\section{Coq}
\begin{frame}
\frametitle{O que é Coq?}
\begin{itemize}
    \item Coq é um assistentes de provas desenvolvido desde 1984 pelo French Institute for Research in Computer Science and Automation (INRIA).
    \item Coq é fruto de sistemas de tipos: baseado em \textbf{Higher order dependently typed polymorphic lambda calculus}, o nomeado Calculus of Constructions (CoC).
    \item Coq suporta programação com tipos dependentes.
    \item Coq tem vÃ¡rias linguagens:
        \begin{enumerate}
            \item Gallina: linguagem de programação funcional total e com tipos dependentes.
            \item Vernecular: linguagem de comandos. Enunciar teoremas, funções...
            \item Tatic: linguagem das táticas usada para criar provas com a ajuda do essistente/verificador.
            \item LTac: criação de novas táticas e procedimentos de prova.
        \end{enumerate}
\end{itemize}
\end{frame}

\section{A linguagem}

\begin{frame}[fragile]
\frametitle{A linguagem: STLC}
\begin{itemize}
  \item Cálculo Lambda Simplesmente Tipado: \textit{Simple Typed Lambda Calculus} (STLC).
\end{itemize}
\begin{verbatim}
t ::= x                       variable
    | \x:T1.t2                abstraction
    | t1 t2                   application
    | true                    constant true
    | false                   constant false
    | if t1 then t2 else t3   conditional

T ::= Bool
    | T1 -> T2
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Formalização de STLC em Coq}
\begin{verbatim}
Inductive ty : Type :=
  | TBool  : ty
  | TArrow : ty -> ty -> ty.

Inductive tm : Type :=
  | tvar : string -> tm
  | tapp : tm -> tm -> tm
  | tabs : string -> ty -> tm -> tm
  | ttrue : tm
  | tfalse : tm
  | tif : tm -> tm -> tm -> tm.
\end{verbatim}
\end{frame}

\section{Semântica Small-Step}
\begin{frame}[fragile]
\frametitle{Semântica Small-Step}
\begin{itemize}
  \item A semântica \textit{small-step} é uma relação de termo para termo que define como os passos atômicos da computação ocorrem. 
  \item No Cálculo Lambda o passo da computação é a redução-beta.
  \item Redução-beta é definida por meio da regra de substituição.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Regras de substituição}
Utiliza-se uma versão simplificada das regras de substuição, onde $s$ é sempre um termo fechado.
\begin{verbatim}
[x:=s]x               = s
[x:=s]y               = y                      if x <> y
[x:=s](\x:T11. t12)   = \x:T11. t12
[x:=s](\y:T11. t12)   = \y:T11. [x:=s]t12      if x <> y
[x:=s](t1 t2)         = ([x:=s]t1) ([x:=s]t2)
[x:=s]true            = true
[x:=s]false           = false
[x:=s](if t1 then t2 else t3) =
                if [x:=s]t1 then [x:=s]t2 else [x:=s]t3
\end{verbatim}
\end{frame}

\end{document}