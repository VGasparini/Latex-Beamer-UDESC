\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage[portuges]{babel}


\title[Uso de Coq para verificação de propriedades de sistemas de tipos]{Uso de Coq para verificação de propriedades de sistemas de tipos}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{22 de Junho de 2018}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\section{Introdução}
\begin{frame}
\frametitle{O que são assistentes de provas?}
\begin{itemize}
    \item Assistentes de provas ou provadores interativos são programas para o desenvolvimento de provas
          formais.
    \item O núcleo de um assistente de provas é um verificador, que verifica a consistência lógica da prova.
    \item Fornecem de maneira interativa de visualizar as informações sobre o estado atual da prova.
    \item A verificação humana de provas é demorada e sujeita a falhas: Último Teorema de Fermat.

      Assistentes de provas permitem provar coisas que não seriam realizáveis somente com papel e caneta!
\end{itemize}
\end{frame}

\section{Coq}
\begin{frame}
\frametitle{O que é Coq?}
\begin{itemize}
    \item Coq é um assistentes de provas desenvolvido desde 1984 pelo French Institute for Research in Computer Science and Automation (INRIA).
    \item Coq é fruto de sistemas de tipos: baseado em \textbf{Higher order dependently typed polymorphic lambda calculus}, o nomeado Calculus of Constructions (CoC).
    \item Coq suporta programação com tipos dependentes.
    \item Coq tem vÃ¡rias linguagens:
        \begin{enumerate}
            \item Gallina: linguagem de programação funcional total e com tipos dependentes.
            \item Vernecular: linguagem de comandos. Enunciar teoremas, funções...
            \item Tatic: linguagem das táticas usada para criar provas com a ajuda do essistente/verificador.
            \item LTac: criação de novas táticas e procedimentos de prova.
        \end{enumerate}
\end{itemize}
\end{frame}

\section{A linguagem}

\begin{frame}[fragile]
\frametitle{A linguagem: STLC}
\begin{itemize}
  \item Cálculo Lambda Simplesmente Tipado: \textit{Simple Typed Lambda Calculus} (STLC).
\end{itemize}
\begin{verbatim}
t ::= x                       variable
    | \x:T1.t2                abstraction
    | t1 t2                   application
    | true                    constant true
    | false                   constant false
    | if t1 then t2 else t3   conditional

T ::= Bool
    | T1 -> T2
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Formalização de STLC em Coq}
\begin{verbatim}
Inductive ty : Type :=
  | TBool  : ty
  | TArrow : ty -> ty -> ty.

Inductive tm : Type :=
  | tvar : string -> tm
  | tapp : tm -> tm -> tm
  | tabs : string -> ty -> tm -> tm
  | ttrue : tm
  | tfalse : tm
  | tif : tm -> tm -> tm -> tm.
\end{verbatim}
\end{frame}

\section{Semântica e Sistemas de Tipos}
\begin{frame}[fragile]
\frametitle{Semântica Small-Step}
\begin{itemize}
  \item A semântica \textit{small-step} é uma relação de termo para termo que define como os passos atômicos da computação ocorrem. 
  \item No Cálculo Lambda o passo da computação é a redução-beta.
  \item Redução-beta é definida por meio da regra de substituição.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Regras de substituição}
Utiliza-se uma versão simplificada das regras de substuição, onde $s$ é sempre um termo fechado (sem variáveis livres).
\begin{verbatim}
[x:=s]x               = s
[x:=s]y               = y                      if x <> y
[x:=s](\x:T11. t12)   = \x:T11. t12
[x:=s](\y:T11. t12)   = \y:T11. [x:=s]t12      if x <> y
[x:=s](t1 t2)         = ([x:=s]t1) ([x:=s]t2)
[x:=s]true            = true
[x:=s]false           = false
[x:=s](if t1 then t2 else t3) =
                if [x:=s]t1 then [x:=s]t2 else [x:=s]t3
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{ Formalização das Regras de substituição em Coq como \textit{Fixpoint}}

\begin{verbatim}
Reserved Notation "'[' x ':=' s ']' t" (at level 20).

Fixpoint subst (x:string) (s:tm) (t:tm) : tm :=
  match t with
  | tvar x'      => if beq_string x x' then s else t
  | tabs x' T t1 => tabs x' T (if beq_string x x'
                                then t1 else ([x:=s] t1))
  | tapp t1 t2   => tapp ([x:=s] t1) ([x:=s] t2)
  | ttrue        => ttrue
  | tfalse       => tfalse
  | tif t1 t2 t3 => tif ([x:=s] t1) ([x:=s] t2) ([x:=s] t3)
  end
where "'[' x ':=' s ']' t" := (subst x s t).
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{ Regras \textit{Small Step}}
A computação no Cálculo Lambda é definida pela Redução Beta, a qual substitui o
argumento pela variável ligada na abstração lambda. A Redução Beta, aqui, é denotada por
\lstinline{(\x:T.t12) v2 ==> [x:=v2]t12}.

As regras \textit{Small Step} definem uma avaliação \textit{eager} conforme:
\begin{prooftree}
  \AxiomC{value v2}
  \RightLabel{(AppAbs)}
  \UnaryInfC{(\lstinline{\x:T.t12) v2 ==> [x:=v2]t12}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{\lstinline{t1 ==> t1'}}
  \RightLabel{(App1)}
  \UnaryInfC{\lstinline{t1 t2 ==> t1' t2}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{\lstinline{value v1}}
  \AxiomC{\lstinline{t2 ==> t2'}}
  \RightLabel{(App2)}
  \BinaryInfC{\lstinline{v1 t2 ==> v1 t2'}}
\end{prooftree}
\end{frame}

\begin{frame}[fragile]
\frametitle{ Regras \textit{Small Step}}
Regras para condicionais:

\begin{prooftree}
  \AxiomC{}
  \RightLabel{(IfTrue)}
  \UnaryInfC{\lstinline{(if true then t1 else t2) ==> t1}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{(IfFalse)}
  \UnaryInfC{\lstinline{(if false then t1 else t2) ==> t2}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{\lstinline{t1 ==> t1'}}
  \RightLabel{(If)}
  \UnaryInfC{\lstinline{(if t1 then t2 else t3) ==> (if t1' then t2 else t3)}}
\end{prooftree}
\end{frame}

\begin{frame}[fragile]
\frametitle{Formalização das  Regras \textit{Small Step} em Coq}
\begin{verbatim}
Reserved Notation "t1 '==>' t2" (at level 40).
Inductive step : tm -> tm -> Prop :=
  | ST_AppAbs : forall x T t12 v2,
         value v2 ->
         (tapp (tabs x T t12) v2) ==> [x:=v2]t12
  | ST_App1 : forall t1 t1' t2,
         t1 ==> t1' ->
         tapp t1 t2 ==> tapp t1' t2
  | ST_App2 : forall v1 t2 t2',
         value v1 -> t2 ==> t2' ->
         tapp v1 t2 ==> tapp v1  t2'
where "t1 '==>' t2" := (step t1 t2).
\end{verbatim}
\end{frame}
\end{document}