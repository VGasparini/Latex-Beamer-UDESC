\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{booktabs}
\usepackage[portuges]{babel}
\usepackage{minted}

\usemintedstyle[haskell]{bw}

\title[Vis\~ao Categ\'orica do Sistema de Tipos de Haskell]{Vis\~ao Categ\'orica do Sistema de Tipos de Haskell}

\author[Rafael Castro Gon\c{c}alves Silva]{
  Rafael Castro Gon\c{c}alves Silva\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

  \institute[UDESC]{
    Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

  \begin{frame}
    \titlepage

  \end{frame}

  \begin{frame}
    \frametitle{Sum\'ario}

    \begin{itemize}
      \item Correspond\^encia Curry-Howard-Lambek
      \item An\'alise do Sistema de Tipos de Haskell
      \item Conclus\~oes
    \end{itemize}
  \end{frame}

  \section{Correspond\^encia Curry-Howard-Lambek}
  \begin{frame}
    \frametitle{C\'alculo Lambda Simplesmente Tipado}
  \end{frame}

  \begin{frame}
    \frametitle{Fragmento da Dedu\c{c}\~ao Natural}
  \end{frame}

  \begin{frame}
    \frametitle{Isomorfismo de Curry-Howard}
    \begin{itemize}
      \item H\'a um isomorfismo entre o Fragmento da Dedu\c{c}\~ao Natural Intuicionista e o C\'alculo Lambda Simplesmente Tipado.
    \pause
      \item A prova de Curry-Howard \'e uma indu\c{c}\~ao estruturada.
        \begin{itemize}
          \item Proposi\c{c}\~oes $\leftrightarrow$ tipos e termos $\leftrightarrow$ provas.
          \item Normaliza\c{c}\~ao de termos $\leftrightarrow$ simplifica\c{c}\~ao de provas.
        \end{itemize}
      \item 
\begin{align*}
    \text{F\'ormulas} & \leftrightarrow \text{Tipos}\\
    \text{Provas} & \leftrightarrow \text{Termos}\\
    \text{Redu\c{c}\~ao-}\beta & \leftrightarrow \text{Simplifica\c{c}\~ao de provas}\\
    \text{Provabilidade} & \leftrightarrow \textit{Inhabitation}\\
    \text{Teorema} & \leftrightarrow \text{Tipo habitado}
\end{align*}
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{Curry-Howard-Lambek}
    \begin{itemize}
      \item Existe uma interpreta\c{c}\~ao categ\'orica para TA e ND: ambos os sistemas
        s\~ao categorias cartesianas fechadas.
        \pause
      \item Em particular, \'e poss\'ivel demonstrar que qualquer lambda-teoria determina uma CCC e, inversamente,
        uma CCC qualquer gera um c\'alculo lambda tipado.
        \pause
      \item Dedu\c{c}\~ao Natural Intuicionista \'e uma CCC:\\
        proposi\c{c}\~oes s\~ao objetos e sequentes s\~ao morfismos.
        \pause
      \item C\'alculo Lambda Simplesmente Tipado \'e uma CCC:\\
        tipos s\~ao objetos e fun\c{c}\~oes s\~ao morfismos.
    \end{itemize}
  \end{frame}


  \section{An\'alise do Sistema de Tipos de Haskell}
  \begin{frame}[fragile]
    \frametitle{Vis\~ao L\'ogica do Sistema de Tipos de Haskell}
    \begin{itemize}
      \item Em Haskell existe o termo \mintinline{haskell}{undefined :: a}, que serve
        para representar uma computa\c{c}\~ao com erro ou um loop infinito. Funciona como um termo
        ``coringa'', pois seu tipo unifica para qualquer outro. Qualquer tipo \'e habitado por ele.
        \pause
      \item A l\'ogica isomorfa ao sistema de tipos de Haskell tem todas as proposi\c{c}\~oes como teoremas.
        \pause
      \item Haskell n\~ao tem o tipo $\bot$, pois n\~ao h\'a tipo n\~ao habitado.
        \pause
      \item Portanto, o sistema de tipos de Haskell \'e n\~ao trivial.

    \end{itemize}
\end{frame}

  \begin{frame}[fragile]
    \frametitle{\textit{Theorems for free!} em Haskell}
    \begin{itemize}
      \item \textit{Theorems for free!} \'e sobre a possibilidade de derivar teoremas a partir
        de fun\c{c}\~oes polim\'orficas (param\'etricas). - Tamb\'em referenciado como Teorema
        da Abstra\c{c}\~ao de Reynolds.
        \pause
      \item Por exemplo, se fornecida uma fun\c{c}\~ao
      \begin{minted}{haskell}
        f :: [a] -> [a]
      \end{minted}
    deduz-se: para todos os tipos \mintinline{haskell}{a} e \mintinline{haskell}{b}, para
      toda lista \mintinline{haskell}{xs :: [a]}, e para toda fun\c{c}\~ao total \mintinline{haskell}{g :: a -> b},
        tem-se a igualdade
      \begin{minted}[escapeinside=||,mathescape=true]{haskell}
        map g (f xs) = f (map g xs) ou
      \end{minted}
      \begin{minted}[escapeinside=||,mathescape=true]{haskell}
        (map g) |$\circ$| f = f |$\circ$| (map g).
      \end{minted}

    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{\textit{Theorems for free!} em Haskell}
    \begin{itemize}
      \item H\'a, em Haskell, a fun\c{c}\~ao \mintinline{haskell}{seq :: a -> b -> b} que serve para a introduzir 
        avalia\c{c}\~ao estrita: o primeiro argumento \'e avaliado de maneira estrita e o segundo \'e retornado.
      \begin{minted}[escapeinside=||,mathescape=true]{haskell}
        seq |$\bot$| b =  |$\bot$|
        seq _ b = b
      \end{minted}
      \pause
        \item
          Com \mintinline{haskell}{seq} \'e poss\'ivel definir a fun\c{c}\~ao 
\begin{minted}{haskell}
  tail_seq :: [a] -> [a]
  tail_seq (x:xs) = seq x xs,
\end{minted}
ent\~ao tomando \mintinline{haskell}{tail_seq} como \mintinline{haskell}{f} e \mintinline{haskell}{const 1} como \mintinline{haskell}{g},
o teorema anterior \'e quebrado, pois
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  map (const 1) (tail_seq [1 `div` 0]) = |$\bot$|
  tail_seq (map (const 1) [1 `div` 0]) = [].
\end{minted}


      \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{Vis\~ao Categ\'orica do Sistema de Tipos de Haskell}
  \end{frame}

  \section{Conclus\~oes}
  \begin{frame}
    \frametitle{Conclus\~oes}
  \end{frame}

\end{document}
