\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage[portuges]{babel}


\title[Uso de Coq para verificação de propriedades de sistemas de tipos]{Uso de Coq para verificação de propriedades de sistemas de tipos}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{22 de Junho de 2018}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\section{Introdução}
\begin{frame}
\frametitle{O que são assistentes de provas?}
\begin{itemize}
    \item Assistentes de provas ou provadores interativos são programas para o desenvolvimento de provas
          formais.
    \item O núcleo de um assistente de provas é um verificador, que verifica a consistência lógica da prova.
    \item Fornecem de maneira interativa de visualizar as informações sobre o estado atual da prova.
    \item A verificação humana de provas é demorada e sujeita a falhas: Último Teorema de Fermat.

      Assistentes de provas permitem provar coisas que não seriam realizáveis somente com papel e caneta!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{O que é Coq?}
\begin{itemize}
    \item Coq é um assistentes de provas desenvolvido desde 1984 pelo French Institute for Research in Computer Science and Automation (INRIA).
    \item Coq é fruto de sistemas de tipos: baseado em \textbf{Higher order dependently typed polymorphic lambda calculus}, o nomeado Calculus of Constructions (CoC).
    \item Coq suporta programação com tipos dependentes.
    \item Coq tem quatro linguagens:
        \begin{enumerate}
            \item Gallina: linguagem de programação funcional total e com tipos dependentes.
            \item Vernecular: linguagem de comandos. Enunciar teoremas, funções...
            \item Tatic: linguagem das táticas usada para criar provas com a ajuda do essistente/verificador.
            \item LTac: criação de novas táticas e procedimentos de prova.
        \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Objetivo do SEC}
\begin{itemize}
  \item Formalizar uma linguagem de programação funcional em Coq.
    \begin{itemize}
    \item Sintaxe: termos e tipos;
    \item Semântica: \textit{Small Step};
    \item Sistemas de tipos: Regras de inferência de tipo;
    \end{itemize}
   \item Provar propriedades do sistema de tipos
\end{itemize}
\end{frame}

\section{A linguagem: STLC}

\begin{frame}[fragile]
\frametitle{A linguagem: STLC}
\begin{itemize}
  \item Cálculo Lambda Simplesmente Tipado: \textit{Simple Typed Lambda Calculus} (STLC).
\end{itemize}
\begin{verbatim}
t ::= x                       variable
    | \x:T1.t2                abstraction
    | t1 t2                   application
    | true                    constant true
    | false                   constant false
    | if t1 then t2 else t3   conditional

T ::= Bool
    | T1 -> T2
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Formalização em Coq de STLC}
\begin{verbatim}
Inductive ty : Type :=
  | TBool  : ty
  | TArrow : ty -> ty -> ty.

Inductive tm : Type :=
  | tvar : string -> tm
  | tapp : tm -> tm -> tm
  | tabs : string -> ty -> tm -> tm
  | ttrue : tm
  | tfalse : tm
  | tif : tm -> tm -> tm -> tm.
\end{verbatim}
\end{frame}

\section{Semântica e Sistemas de Tipos}
\begin{frame}[fragile]
\frametitle{Semântica Small-Step}
\begin{itemize}
  \item A semântica \textit{small-step} é uma relação de termo para termo que define como os passos atômicos da computação ocorrem. 
  \item No Cálculo Lambda o passo da computação é a redução-beta.
  \item Redução-beta é definida por meio da regra de substituição.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Regras de substituição}
Utiliza-se uma versão simplificada das regras de substuição, onde $s$ é sempre um termo fechado (sem variáveis livres).
\begin{verbatim}
[x:=s]x               = s
[x:=s]y               = y                      if x <> y
[x:=s](\x:T11. t12)   = \x:T11. t12
[x:=s](\y:T11. t12)   = \y:T11. [x:=s]t12      if x <> y
[x:=s](t1 t2)         = ([x:=s]t1) ([x:=s]t2)
[x:=s]true            = true
[x:=s]false           = false
[x:=s](if t1 then t2 else t3) =
                if [x:=s]t1 then [x:=s]t2 else [x:=s]t3
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{ Formalização em Coq das Regras de substituição como \textit{Fixpoint}}

\begin{verbatim}
Reserved Notation "'[' x ':=' s ']' t" (at level 20).

Fixpoint subst (x:string) (s:tm) (t:tm) : tm :=
  match t with
  | tvar x'      => if beq_string x x' then s else t
  | tabs x' T t1 => tabs x' T (if beq_string x x'
                                then t1 else ([x:=s] t1))
  | tapp t1 t2   => tapp ([x:=s] t1) ([x:=s] t2)
  | ttrue        => ttrue
  | tfalse       => tfalse
  | tif t1 t2 t3 => tif ([x:=s] t1) ([x:=s] t2) ([x:=s] t3)
  end
where "'[' x ':=' s ']' t" := (subst x s t).
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{ Regras \textit{Small Step}}
A computação no Cálculo Lambda é definida pela Redução Beta, a qual substitui o
argumento pela variável ligada na abstração lambda. A Redução Beta, aqui, é denotada por
\lstinline{(\x:T.t12) v2 ==> [x:=v2]t12}.

As regras \textit{Small Step} definem uma avaliação \textit{eager} conforme:
\begin{prooftree}
  \AxiomC{value v2}
  \RightLabel{(AppAbs)}
  \UnaryInfC{(\lstinline{\x:T.t12) v2 ==> [x:=v2]t12}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{\lstinline{t1 ==> t1'}}
  \RightLabel{(App1)}
  \UnaryInfC{\lstinline{t1 t2 ==> t1' t2}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{\lstinline{value v1}}
  \AxiomC{\lstinline{t2 ==> t2'}}
  \RightLabel{(App2)}
  \BinaryInfC{\lstinline{v1 t2 ==> v1 t2'}}
\end{prooftree}
\end{frame}

\begin{frame}[fragile]
\frametitle{ Regras \textit{Small Step}}
Regras para condicionais:

\begin{prooftree}
  \AxiomC{}
  \RightLabel{(IfTrue)}
  \UnaryInfC{\lstinline{(if true then t1 else t2) ==> t1}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{(IfFalse)}
  \UnaryInfC{\lstinline{(if false then t1 else t2) ==> t2}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{\lstinline{t1 ==> t1'}}
  \RightLabel{(If)}
  \UnaryInfC{\lstinline{(if t1 then t2 else t3) ==> (if t1' then t2 else t3)}}
\end{prooftree}
\end{frame}

\begin{frame}[fragile]
\frametitle{Formalização em Coq das  Regras \textit{Small Step}}
\begin{verbatim}
Reserved Notation "t1 '==>' t2" (at level 40).
Inductive step : tm -> tm -> Prop :=
  | ST_AppAbs : forall x T t12 v2,
         value v2 ->
         (tapp (tabs x T t12) v2) ==> [x:=v2]t12
  | ST_App1 : forall t1 t1' t2,
         t1 ==> t1' ->
         tapp t1 t2 ==> tapp t1' t2
  | ST_App2 : forall v1 t2 t2',
         value v1 -> t2 ==> t2' ->
         tapp v1 t2 ==> tapp v1  t2'
where "t1 '==>' t2" := (step t1 t2).
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sistema de Tipos}
\begin{itemize}
\item Interpreta-se a tripla relação $\Gamma \vdash$ \lstinline{t : T} como:
Sobre as suposições $\Gamma$, o termo \lstinline{t} tem o tipo \lstinline{T}.
\item O sistema de tipos é dado pelas regras de inferência abaixo:
\end{itemize}

\begin{prooftree}
  \AxiomC{}
  \RightLabel{(Var)}
  \UnaryInfC{$\Gamma$ \lstinline{,x : T} $\vdash$ \lstinline{x : T}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{$\Gamma$ \lstinline{, x : T11} $\vdash$ \lstinline{t12 : T12}}
  \RightLabel{(Abs)}
  \UnaryInfC{$\Gamma \vdash$ \lstinline{(\x:T11.t12) : T11->T12}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{$\Gamma \vdash$\lstinline{t1 : T11 -> T12}}
  \AxiomC{$\Gamma \vdash$\lstinline{t2 : T11}}
  \RightLabel{(App)}
  \BinaryInfC{$\Gamma \vdash$\lstinline{t1 t2 : T12}}
\end{prooftree}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sistema de Tipos}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{(True)}
  \UnaryInfC{$\Gamma \vdash$ \lstinline{true : Bool}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{(False)}
  \UnaryInfC{$\Gamma \vdash$ \lstinline{false : Bool}}
\end{prooftree}
\begin{prooftree}
  \AxiomC{$\Gamma \vdash$ \lstinline{t1 : Bool}}
  \AxiomC{$\Gamma \vdash$ \lstinline{t2 : T}}
  \AxiomC{$\Gamma \vdash$ \lstinline{t3 : T}}
  \RightLabel{(If)}
  \TrinaryInfC{$\Gamma \vdash$ \lstinline{if t1 the t2 else t3 : T}}
\end{prooftree}
\end{frame}


\begin{frame}[fragile]
\frametitle{Formalização  em Coq do Sistema de Tipos}
\begin{verbatim}
Definition context := partial_map ty.

Reserved Notation "Gamma '|-' t '\in' T" (at level 40).
Inductive has_type : context -> tm -> ty -> Prop :=
  | T_Var : forall Gamma x T, Gamma x = Some T ->
      Gamma |- tvar x \in T
  | T_Abs : forall Gamma x T11 T12 t12,
      Gamma & {{x --> T11}} |- t12 \in T12 ->
      Gamma |- tabs x T11 t12 \in TArrow T11 T12
  | T_App : forall T11 T12 Gamma t1 t2,
      Gamma |- t1 \in TArrow T11 T12 ->
      Gamma |- t2 \in T11 ->
      Gamma |- tapp t1 t2 \in T12
where "Gamma '|-' t '\in' T" := (has_type Gamma t T).
\end{verbatim}
\end{frame}

\section{Propriedades do Sistema de Tipos}
\begin{frame}[fragile]
\frametitle{Progresso}
A propriedade de progresso diz que todo termo fechado e bem tipado não está
travado \textit{stuck}, ou seja, ou é um valor ou pode fazer um passo de redução.
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
