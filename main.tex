\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{booktabs}
\usepackage[portuges]{babel}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{pdflscape}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{amsmath, amsthm, amsfonts, amssymb}
\usepackage{minted}

\usetikzlibrary{matrix}
\usetikzlibrary{arrows,calc, shapes,fit, positioning} 
\usemintedstyle[haskell]{bw}

\title[Vis\~ao Categ\'orica do Sistema de Tipos de Haskell]{Vis\~ao Categ\'orica do Sistema de Tipos de Haskell}

\author[Rafael Castro Gon\c{c}alves Silva]{
  Rafael Castro Gon\c{c}alves Silva\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

  \institute[UDESC]{
    Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

  \begin{frame}
    \titlepage

  \end{frame}

  \begin{frame}
    \frametitle{Sum\'ario}

    \begin{itemize}
      \item Correspond\^encia Curry-Howard-Lambek
      \item An\'alise do Sistema de Tipos de Haskell
      \item Conclus\~oes
    \end{itemize}
  \end{frame}

  \section{Correspond\^encia Curry-Howard-Lambek}
%  \begin{frame}
%    \frametitle{C\'alculo Lambda Simplesmente Tipado}
%  \end{frame}
%
%  \begin{frame}
%    \frametitle{Fragmento da Dedu\c{c}\~ao Natural}
%  \end{frame}
%
  \begin{frame}
    \frametitle{Isomorfismo de Curry-Howard}
    \begin{itemize}
      \item H\'a um isomorfismo entre o Fragmento da Dedu\c{c}\~ao Natural Intuicionista e o C\'alculo Lambda Simplesmente Tipado.
    \pause
      \item A prova de Curry-Howard \'e uma indu\c{c}\~ao estruturada.
        \begin{itemize}
          \item Proposi\c{c}\~oes $\leftrightarrow$ tipos e termos $\leftrightarrow$ provas.
          \item Normaliza\c{c}\~ao de termos $\leftrightarrow$ simplifica\c{c}\~ao de provas.
        \end{itemize}
      \item 
\begin{align*}
    \text{F\'ormulas} & \leftrightarrow \text{Tipos}\\
    \text{Provas} & \leftrightarrow \text{Termos}\\
    \text{Redu\c{c}\~ao-}\beta & \leftrightarrow \text{Simplifica\c{c}\~ao de provas}\\
    \text{Provabilidade} & \leftrightarrow \textit{Inhabitation}\\
    \text{Teorema} & \leftrightarrow \text{Tipo habitado}
\end{align*}
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{Curry-Howard-Lambek}
    \begin{itemize}
      \item Existe uma interpreta\c{c}\~ao categ\'orica para TA e ND: ambos os sistemas
        s\~ao categorias cartesianas fechadas.
        \pause
      \item Em particular, \'e poss\'ivel demonstrar que qualquer lambda-teoria determina uma CCC e, inversamente,
        uma CCC qualquer gera um c\'alculo lambda tipado.
        \pause
      \item Dedu\c{c}\~ao Natural Intuicionista \'e uma CCC:\\
        proposi\c{c}\~oes s\~ao objetos e sequentes s\~ao morfismos.
        \pause
      \item C\'alculo Lambda Simplesmente Tipado \'e uma CCC:\\
        tipos s\~ao objetos e fun\c{c}\~oes s\~ao morfismos.
    \end{itemize}
  \end{frame}


  \section{An\'alise do Sistema de Tipos de Haskell}
  \begin{frame}[fragile]
    \frametitle{Vis\~ao L\'ogica do Sistema de Tipos de Haskell}
    \begin{itemize}
      \item Em Haskell existe o termo \mintinline{haskell}{undefined :: a}, que serve
        para representar uma computa\c{c}\~ao com erro ou um loop infinito. Funciona como um termo
        ``coringa'', pois seu tipo unifica para qualquer outro. Qualquer tipo \'e habitado por ele.
        \pause
      \item A l\'ogica isomorfa ao sistema de tipos de Haskell tem todas as proposi\c{c}\~oes como teoremas.
        \pause
      \item Haskell n\~ao tem o tipo $\bot$, pois n\~ao h\'a tipo n\~ao habitado.
        \pause
      \item Portanto, o sistema de tipos de Haskell \'e n\~ao trivial.

    \end{itemize}
\end{frame}

  \begin{frame}[fragile]
    \frametitle{\textit{Theorems for free!} em Haskell}
    \begin{itemize}
      \item \textit{Theorems for free!} \'e sobre a possibilidade de derivar teoremas a partir
        de fun\c{c}\~oes polim\'orficas (param\'etricas). - Tamb\'em referenciado como Teorema
        da Abstra\c{c}\~ao de Reynolds.
        \pause
      \item Por exemplo, se fornecida uma fun\c{c}\~ao
      \begin{minted}{haskell}
        f :: [a] -> [a]
      \end{minted}
    deduz-se: para todos os tipos \mintinline{haskell}{a} e \mintinline{haskell}{b}, para
      toda lista \mintinline{haskell}{xs :: [a]}, e para toda fun\c{c}\~ao total \mintinline{haskell}{g :: a -> b},
        tem-se a igualdade
      \begin{minted}[escapeinside=||,mathescape=true]{haskell}
        map g (f xs) = f (map g xs) ou
      \end{minted}
      \begin{minted}[escapeinside=||,mathescape=true]{haskell}
        (map g) |$\circ$| f = f |$\circ$| (map g).
      \end{minted}

    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{\textit{Theorems for free!} em Haskell}
    \begin{itemize}
      \item H\'a, em Haskell, a fun\c{c}\~ao \mintinline{haskell}{seq :: a -> b -> b} que serve para a introduzir 
        avalia\c{c}\~ao estrita: o primeiro argumento \'e avaliado de maneira estrita e o segundo \'e retornado.
      \begin{minted}[escapeinside=||,mathescape=true]{haskell}
        seq |$\bot$| b =  |$\bot$|
        seq _ b = b
      \end{minted}
      \pause
        \item
          Com \mintinline{haskell}{seq} \'e poss\'ivel definir a fun\c{c}\~ao 
\begin{minted}{haskell}
  tail_seq :: [a] -> [a]
  tail_seq (x:xs) = seq x xs,
\end{minted}
ent\~ao tomando \mintinline{haskell}{tail_seq} como \mintinline{haskell}{f} e \mintinline{haskell}{const 1} como \mintinline{haskell}{g},
o teorema anterior \'e quebrado, pois
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  map (const 1) (tail_seq [1 `div` 0]) = |$\bot$|
  tail_seq (map (const 1) [1 `div` 0]) = [].
\end{minted}
      \end{itemize}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Vis\~ao Categ\'orica do Sistema de Tipos de Haskell}
    \begin{block}{\small{Segundo a \textit{Wiki} do Haskell:}}
Os objetos de \textbf{Hask} s\~ao tipos de Haskell e os morfismos dos objetos
  \mintinline{haskell}{A} a \mintinline{haskell}{B} s\~ao fun\c{c}\~oes de Haskell do tipo \mintinline{haskell}{A ->  B}.
  O morfismo identidade do objeto \mintinline{haskell}{A} \'e \mintinline{haskell}{id :: A -> A},
  e a composi\c{c}\~ao dos morfismos \mintinline{haskell}{f} e \mintinline{haskell}{g} \'e \mintinline{haskell}{f . g = x -> f (g x)}.  
(Tradu\c{c}\~ao do autor) 
\end{block}
\pause
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  undef1 :: a -> b
  undef1 = undefined

  undef2 :: a -> b
  undef2 = \_ -> undefined
\end{minted}
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  seq undef1 1 = |$\bot$|
  seq undef2 1 = 1
\end{minted}
\mintinline{haskell}{undef1 . id = undef2} $\Longrightarrow$
\mintinline[escapeinside=||,mathescape=true]{haskell}{undef1 . id |$\not =$| undef1}.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Categoria \textbf{PHask}}

\begin{enumerate}[(a)]
  \item $Obj_{PHask}$ \'e o conjunto de todos os tipos de Haskell. 
  \item $Mor_{PHask}$ \'e o conjunto de todas as fun\c{c}\~oes em Haskell (tip\'aveis)
    que s\~ao totais. Al\'em disso, um morfismo \mintinline[escapeinside=||,mathescape=true]{haskell}{f : A |$\rightarrow$| B}
    representa a classe de equival\^encia de fun\c{c}\~oes do tipo \mintinline[escapeinside=||,mathescape=true]{haskell}{A} ao tipo \mintinline[escapeinside=||,mathescape=true]{haskell}{B} que tem o
    mesmo mapeamento.
  \item $\partial_0$ e $\partial_1$ s\~ao as fun\c{c}\~oes que levam, respectivamente, uma fun\c{c}\~ao ao seu tipo de
    origem e destino.
  \item A composi\c{c}\~ao \'e dada pela fun\c{c}\~ao \mintinline[escapeinside=||,mathescape=true]{haskell}{(.) :: (b -> c) -> (a -> b) -> a -> c} e a prova da associatividade
    \'e a mesma utilizada em \textbf{Set}.
  \item O morfimso identidade \'e gerado pelas fun\c{c}\~oes identidade \mintinline[escapeinside=||,mathescape=true]{haskell}{id :: a -> a}, que pelo polimorfismo garante que todo objeto (tipo)
    tem um morfismo (fun\c{c}\~ao) identidade. Observa-se que \textbf{PHask}, diferente de \textbf{Hask},
    n\~ao acontece 
    \mintinline[escapeinside=||,mathescape=true]{haskell}{undef1 . id |$\not =$| undef1}.
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A categoria \textbf{PHask} \'e uma categoria cartesiana fechada}

\begin{enumerate}
  \item O objeto terminal \'e o tipo \mintinline[escapeinside=||,mathescape=true]{haskell}{()}.
  \item Utiliza-se o dado tupla padr\~ao: o produto \'e dado pelos morfismos das fun\c{c}\~oes \mintinline[escapeinside=||,mathescape=true]{haskell}{fst :: (a, b) -> a} e \mintinline[escapeinside=||,mathescape=true]{haskell}{snd :: (a, b) -> b}, e  
pelo tipo: \mintinline[escapeinside=||,mathescape=true]{haskell}{ data (a,b) = (,) { fst :: a, snd :: b}.}
Assim, para qualquer tipo \mintinline[escapeinside=||,mathescape=true]{haskell}{r} e para quaisquer fun\c{c}\~oes \mintinline[escapeinside=||,mathescape=true]{haskell}{f :: r -> a} e \mintinline[escapeinside=||,mathescape=true]{haskell}{g :: r -> b}
deve existir uma \'unica fun\c{c}\~ao \mintinline[escapeinside=||,mathescape=true]{haskell}{u :: r -> (a,b)} capaz de fazer o diagrama abaixo comutar.\\

    \begin{minipage}{.43\textwidth}
\begin{figure}[H]
    \centering
        \begin{tikzpicture}[line width=1pt,>=latex]
            %\draw[help lines, color=gray!30, dashed] (-4, -4) grid (4,4);
            \node (C) {\mintinline{haskell}{r}};
            \node [below left =2cm of C] (A) {\mintinline{haskell}{a}};
            \node [below right =2cm of C] (B) {\mintinline{haskell}{b}};
            \node [below =1.35 cm of C] (AxB) {\mintinline{haskell}{(a, b)}};
            
            \node[shape=rectangle,draw=black,minimum size=1.9cm,fit={(AxB) (B) (A) (C)}] {};

            \draw[->] (AxB) -- node[above] {\mintinline{haskell}{fst}} (A);
            \draw[->] (AxB) -- node[above] {\mintinline{haskell}{snd}} (B);
            \draw[->] (C) -- node[above right] {\mintinline{haskell}{g}} (B);
            \draw[->] (C) -- node[above left] {\mintinline{haskell}{f}} (A);
            \draw[->] (C) edge [dashed] node[right] {\mintinline{haskell}{u}} (AxB);
        \end{tikzpicture}
    \label{comuproHaskell}
\end{figure}
    \end{minipage}
    \begin{minipage}{.43\textwidth}
    A melhor fun\c{c}\~ao \mintinline[escapeinside=||,mathescape=true]{haskell}{u} que garante a comutatividade desse diagrama somente pode ser:
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  u :: r -> (a, b)
  u r = (f r, g r).
\end{minted}
\end{minipage}
\end{enumerate}
\end{frame}

  \begin{frame}[fragile]
    \begin{enumerate}
        \setcounter{enumi}{2}
  \item O objeto exponencial em Haskell \'e formado pelo objeto \mintinline[escapeinside=||,mathescape=true]{haskell}{b -> c} e pelo morfismo \mintinline[escapeinside=||,mathescape=true]{haskell}{eval}, onde \mintinline[escapeinside=||,mathescape=true]{haskell}{b} e \mintinline[escapeinside=||,mathescape=true]{haskell}{c} s\~ao tipos quaisquer 
    e \mintinline[escapeinside=||,mathescape=true]{haskell}{eval} \'e gerado pela fun\c{c}\~ao
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  eval :: (b -> c, c) -> c
  eval (f, x) = f x,
\end{minted}
pois para todo tipo \mintinline[escapeinside=||,mathescape=true]{haskell}{a}
e fun\c{c}\~ao \mintinline[escapeinside=||,mathescape=true]{haskell}{g :: (a, b) -> c},
existe um \'unico morfismo \mintinline[escapeinside=||,mathescape=true]{haskell}{curry g},
onde 
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  curry :: ((a, b) -> c) -> a -> b -> c
  curry f = \x -> \y -> f (x, y),
\end{minted}
que faz o diagrama abaixo comutar.
\begin{figure}[H]
    \centering
        \begin{tikzpicture}[line width=1pt,>=latex]
            %\draw[help lines, color=gray!30, dashed] (-4, -4) grid (4,4);
          \node (C) {\mintinline{haskell}{a}};
            \node [below = 1cm of C] (BA) {\mintinline{haskell}{b -> c}};
            \node [right = 3.5cm of BA] (BAxA) {\mintinline{haskell}{(b -> c, b)}};
            \node [above = 1cm of BAxA] (CxA) {\mintinline{haskell}{(a, b)}};
            \node [right = 1.5cm of BAxA] (B) {\mintinline{haskell}{c}};
            \node [below = 0.1cm of BAxA] (X) {};
            
            \node[shape=rectangle,draw=black,minimum size=2cm,fit={(C) (BA) (BAxA) (CxA) (B) (X)}] {};

            \draw[->] (C) edge [dashed] node[right] {\mintinline{haskell}{curry g}} (BA);
            \draw[->] (CxA) edge node[left] {\mintinline{haskell}{(curry g, id)}} (BAxA);
            \draw[->] (CxA) edge node[above right] {\mintinline{haskell}{g}} (B);
            \draw[->] (BAxA) edge node[below] {\mintinline{haskell}{eval}} (B);
        \end{tikzpicture}
    \label{comuexp}
\end{figure}
\end{enumerate}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Vis\~ao Categ\'orica de Classes de Tipos}
    \begin{itemize}
      \item As classes de tipos do Haskell s\~ao utilizadas para definir algumas
        estruturas matem\'aticas, como rela\c{c}\~oes (por exemplo: equival\^encia e ordem), semigrupos,
        monoides, funtores e m\^onadas.
        \pause
      \item A classe \mintinline{haskell}{Functor} indica, por seu nome, representar as estruturas categ\'oricas
dos funtores, portanto
deve ser um mapeamento entre categorias, o qual preserva origem e destino dos morfismos, identidade dos 
objetos e a composi\c{c}\~ao
        \pause
      \item Um construtor de tipos \'e uma fun\c{c}\~ao que recebe tipos como argumentos e retorna algum tipo, por exemplo
o construtor \mintinline{haskell}{Either} recebe dois tipos \mintinline{haskell}{a, b} e retorna o tipo
\mintinline{haskell}{Either a b}.
\item 
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  class Functor (f :: * -> *) where
  fmap :: (a -> b) -> f a -> f b.
\end{minted}

    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Vis\~ao Categ\'orica de Classes de Tipos}
    \begin{itemize}
      \item A assinatura de \mintinline{haskell}{fmap} garante a preserva\c{c}\~ao da origem e do destino, por\'em
a identidade e a composi\c{c}\~ao n\~ao s\~ao asseguradas.
Seria necess\'ario que 
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
  fmap id = id
  fmap (f . g) = fmap f . fmap g
\end{minted}

    \end{itemize}
  \end{frame}

  \section{Conclus\~oes}
  \begin{frame}
    \frametitle{Conclus\~oes}
    \begin{itemize}
      \item Curry-Howard-Lambek \'e utilizado no sistema de tipos de Haskell, n\~ao somente para definir
        algumas classes de tipos, mas tamb\'em para garantir o bom comportamento do sistema.
      \item Foi identificado alguns problemas em Haskell, em particular a aus\^encia de uma sem\^antica operacional 
        que seria fundamental para definir uma categoria dos tipos e fun\c{c}\~oes.
      \item Como alternativa foi constru\'ido a categoria \textbf{PHask} a partir de um subconjunto
        de Haskell com apenas fun\c{c}\~oes totais.
    \end{itemize}
  \end{frame}


\end{document}
