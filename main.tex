\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
\usepackage{bussproofs}
%\usepackage[T1]{fontenc}
\usepackage{booktabs}
\usepackage[portuges]{babel}


\title[Extraction of Programs from Proofs]{Extraction of Programs from Proofs}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\date{07/03/2018}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\section{Isomorfismo de Curry-Howard}

\begin{frame}
\frametitle{Sistemas de Provas}
\begin{itemize}
    \item Sistemas/Cálculos de provas servem para construir provas de uma maneira muito formal.
    \item São uma coleção de regras que explicam como derivar novas fórmulas.
    \item Um sistema de prova pode ser utilizado na formalização de diversas lógicas,
      como Lógica Proposicional e Lógica de Predicados.
    \item Os principais sistemas de provas são a Dedução Natural e o Cálculo de Hilbert.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Fragmento Proposicional Clássico da Dedução Natural}
\begin{center}
        \begin{prooftree}
            \AxiomC{}
            \RightLabel{$(\small{hip)}$}
            \UnaryInfC{$u : A$}
        \end{prooftree}
\end{center}

\begin{center}
\begin{minipage}{.4\textwidth}
        \begin{prooftree}
            \AxiomC{$A \rightarrow B$}
            \AxiomC{$A$}
            \RightLabel{$(\rightarrow^-)$}
            \BinaryInfC{$B$}
        \end{prooftree}
\end{minipage}
\begin{minipage}{.4\textwidth}
        \begin{prooftree}
            \AxiomC{$B$}
            \RightLabel{$(\rightarrow^+) \: [u : A]$}
            \UnaryInfC{$A \rightarrow B$}
        \end{prooftree}
\end{minipage}
\end{center}
        
\begin{center}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$A \wedge B$}
            \RightLabel{$(\wedge_l^-)$}
            \UnaryInfC{$A$}
       \end{prooftree}
\end{minipage}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$  A \wedge B$}
            \RightLabel{$(\wedge_r^-)$}
            \UnaryInfC{$B$}
       \end{prooftree}
\end{minipage}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$A$}
            \AxiomC{$B$}
            \RightLabel{$(\wedge^+)$}
            \BinaryInfC{$A \wedge B$}
       \end{prooftree}
\end{minipage}
\end{center}

\begin{center}
\begin{minipage}{.5\textwidth}
        \begin{prooftree}
            \AxiomC{$A \vee B$}
            \AxiomC{$A \rightarrow C$}
            \AxiomC{$B \rightarrow C$}
            \RightLabel{$(\vee^-)$}
            \TrinaryInfC{$C$}
       \end{prooftree}
\end{minipage}
\end{center}

\begin{center}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$A$}
            \RightLabel{$(\vee_l^+)$}
            \UnaryInfC{$A \vee B$}
       \end{prooftree}
\end{minipage}
\begin{minipage}{.2\textwidth}
        \begin{prooftree}
            \AxiomC{$B$}
            \RightLabel{$(\vee_r^+)$}
            \UnaryInfC{$A \vee B$}
       \end{prooftree}
\end{minipage}
\end{center}

\begin{center}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$\bot$}
            \RightLabel{$(efq)$}
            \UnaryInfC{$A$}
        \end{prooftree}
\end{minipage}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$\neg \neg A$}
            \RightLabel{$(raa)$}
            \UnaryInfC{$A$}
        \end{prooftree}
\end{minipage}
\end{center}
onde $\neg A \Rightarrow A \rightarrow \bot$.
\end{frame}

\begin{frame}
\frametitle{Exemplo de Prova em DN}
        \begin{prooftree}
            \AxiomC{$$}
            \RightLabel{(\small{hip)}}
            \UnaryInfC{$u : (A \vee \neg A) \rightarrow \bot$}
            \AxiomC{$$}
            \RightLabel{(\small{hip)}}
            \UnaryInfC{$u : (A \vee \neg A) \rightarrow \bot$}
            \AxiomC{$$}
            \RightLabel{(\small{hip)}}
            \UnaryInfC{$v : A$}
            \RightLabel{$(\vee^+_r)$}
            \UnaryInfC{$A \vee \neg A$}
            \BinaryInfC{$\bot$}
            \RightLabel{$(\rightarrow^+) [v]$}
            \UnaryInfC{$A \rightarrow \bot$}
            \RightLabel{$(\vee^+_l)$}
            \UnaryInfC{$(A \vee \neg A)$}
            \RightLabel{$(\rightarrow^-)$}
            \BinaryInfC{$\bot$}
            \RightLabel{$(\rightarrow^+) [u]$}
            \UnaryInfC{$((A \vee \neg A) \rightarrow \bot) \rightarrow \bot$}
            \RightLabel{$(raa)$}
            \UnaryInfC{$A \vee \neg A$}
        \end{prooftree}
 
\end{frame}

\begin{frame}
\frametitle{Cálculo Lambda}
\begin{itemize}
  \item O Cálculo Lambda é um modelo de computação criado por Alonzo Church em 1933.
  \item O proposito inicial do Cálculo Lambda foi ser uma linguagem de macros para um lógica e assim demonstrar a indecibilidade do problema da parada.
  \item Funciona como um sistema de reescrita: existem regras para reescrever expressões.
  \item A primeira linguagem de programação. Uma década antes do primeiro computador.
\end{itemize}
Sintaxe:
\begin{align*}
  e \: := (e \: e') \: | \: (\lambda x.e) \: | \: x
\end{align*}
Reescrita:
\begin{align*}
  (\lambda x. e) \: e' \Rightarrow_\beta [e'/x]e
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Exemplos de Computação em CL}
1)
\begin{align*}
  (\lambda x.x) \: y \Rightarrow_\beta y
\end{align*}
2)
\begin{align*}
  (\lambda x.x) \: (\lambda x.x) \Rightarrow_\beta \lambda x.x
\end{align*}
3)
\begin{align*}
  ((\lambda x.\lambda y . y) \: a) b \Rightarrow_\beta b
\end{align*}
4)
\begin{align*}
  (\lambda x.x x) \: (\lambda x.x x) \Rightarrow_\beta (\lambda x.x x) \: (\lambda x.x x)
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Cálculo Lambda Tipado}
O Cálculo Lambda é muito poderoso, permite criar o Rightarrowalente de fórmulas lógicas infinitas e assim
a lógica representada é inconsistente.

Para evitar paradoxos Church utilizou o mesmo truque que Bertrand Russel: Type Thoery.

\end{frame}

\begin{frame}
\frametitle{Cálculo Lambda Tipado}
\begin{center}
        \begin{prooftree}
            \AxiomC{}
            \RightLabel{$(\small{hip)}$}
            \UnaryInfC{$x:A \vdash x: A$}
        \end{prooftree}
\end{center}

\begin{center}
\begin{minipage}{.6\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma \vdash e : A \rightarrow B$}
            \AxiomC{$\Gamma \vdash e' : A$}
            \RightLabel{$(\rightarrow^-)$}
            \BinaryInfC{$e \: e' : \Gamma \vdash B$}
        \end{prooftree}
\end{minipage}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma, x:A \vdash e:B$}
            \RightLabel{$(\rightarrow^+)$}
            \UnaryInfC{$\Gamma \vdash \lambda x. e : A \rightarrow B$}
        \end{prooftree}
\end{minipage}
\end{center}
        
\begin{center}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma \vdash e : A * B$}
            \RightLabel{$(fst)$}
            \UnaryInfC{$\Gamma \vdash fst \: e : A$}
       \end{prooftree}
\end{minipage}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma \vdash e :  A * B$}
            \RightLabel{$(snd)$}
            \UnaryInfC{$\Gamma \vdash snd \: e : B$}
       \end{prooftree}
\end{minipage}

\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma \vdash e : A$}
            \AxiomC{$\Gamma \vdash e' : B$}
            \RightLabel{$(pair)$}
            \BinaryInfC{$\Gamma \vdash (e, e') : A \wedge B$}
       \end{prooftree}
\end{minipage}
\end{center}
\begin{align*}
  fst (e, e') & \Rightarrow_\beta e \\
  snd (e, e') & \Rightarrow_\beta e'
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Cálculo Lambda Tipado}
\begin{center}
        \begin{prooftree}
            \AxiomC{$\Gamma \vdash e : A + B$}
            \AxiomC{$\Gamma \vdash e' : A \rightarrow C$}
            \AxiomC{$\Gamma \vdash e'' : B \rightarrow C$}
            \RightLabel{$(+^-)$}
            \TrinaryInfC{$\Gamma \vdash case (e, e', e'') : C$}
       \end{prooftree}
\end{center}

\begin{center}
\begin{minipage}{.4\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma \vdash e : A$}
            \RightLabel{$+^+_l$}
            \UnaryInfC{$\Gamma \vdash (0, e) : A + B$}
       \end{prooftree}
\end{minipage}
\begin{minipage}{.4\textwidth}
        \begin{prooftree}
            \AxiomC{$B$}
            \RightLabel{$+^+_r$}
            \UnaryInfC{$\Gamma \vdash (1, e) : A + B$}
       \end{prooftree}
\end{minipage}
\end{center}

\begin{align*}
  case((0, e), e', e'') & \Rightarrow_\beta e' \: e \\
  case((1, e), e', e'') & \Rightarrow_\beta e'' \: e
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Isomorfismo de Curry-Howard}
O Isomorfismo de Curry-Howard é uma observação que provas construtivas na dedução estão numa
correspondência natural com programas em Cálculo Lambda.

\begin{center}
\begin{minipage}{.4\textwidth}
        \begin{prooftree}
            \AxiomC{$A \rightarrow B$}
            \AxiomC{$A$}
            \RightLabel{$(\rightarrow^-)$}
            \BinaryInfC{$B$}
        \end{prooftree}
\end{minipage}
\begin{minipage}{.4\textwidth}
        \begin{prooftree}
            \AxiomC{$B$}
            \RightLabel{$(\rightarrow^+) \: [u : A]$}
            \UnaryInfC{$A \rightarrow B$}
        \end{prooftree}
\end{minipage}
\end{center}

\begin{center}
\begin{minipage}{.6\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma \vdash e : A \rightarrow B$}
            \AxiomC{$\Gamma \vdash e' : A$}
            \RightLabel{$(\rightarrow^-)$}
            \BinaryInfC{$e \: e' : \Gamma \vdash B$}
        \end{prooftree}
\end{minipage}
\begin{minipage}{.3\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma, x:A \vdash e:B$}
            \RightLabel{$(\rightarrow^+)$}
            \UnaryInfC{$\Gamma \vdash \lambda x. e : A \rightarrow B$}
        \end{prooftree}
\end{minipage}
\end{center}
\end{frame}

\section{Extração de Programas}

\begin{frame}
\frametitle{Realizability}
\end{frame}

\section{Extração em Minlog}

\begin{frame}
\frametitle{Realizability}
\end{frame}

\begin{frame}{Extracting a Logarithm Approximation Algorithm}

\begin{center}
  $\forall n, \exists k \: r, 0 < n \rightarrow n = 2^k + r \wedge r < 2^k$
\end{center}

The intuition here is that we should increase $r$ when $r < 2^k$ or increase $k$ otherwise.  

\end{frame}

\begin{frame}{Sketch of the proof}

  Induction over $n$:
    \begin{enumerate}
       \item Base case: $n = 0$. So since we have $0 < 0$, we just use \textit{efq}.
       \item Step case: $n = Succ \: m$. 
         \begin{enumerate}
           \item The base case of induction is not the base of the recursion in the algorithm, because $log_2 \: 0 = -\infty$.
           \item We do case analysis on $0 < m$, so we have $0 < m$ or $m = 0$.
           \item This way we have two new goals on the induction step:
              \begin{enumerate}
                 \item if $m = 0$, then $n = 1$ (our base case of recursion) and we shall prove:
                   \begin{align*}
                     \exists k \: r, 1 = 2^k + r \wedge r < 2^k
                   \end{align}
                   So $k = r = 0$.
                 \item if $0 < m$, then the recursion can go on and we should prove that: 
                   \begin{align*}
                     \exists k \: r, Succ \: m = 2^k + r \wedge r < 2^k
                   \end{align}
              \end{enumerate}
         \end{enumerate}

    \end{enumerate}

\end{frame}

\begin{frame}{Sketch of the proof}
  Our current goal:\\
  \begin{align*}
    \exists k \: r, Succ \: m = 2^k + r \wedge r < 2^k
  \end{align}
      We need to do case analysis on $Succ \: r < 2 ^k $ because that is rule for
     increasing $k$ or $r$.
   \begin{enumerate}
     \item If $Succ \: r < 2 ^k$, then we chose $k = k$ and $r = Succ \: r'$.
     \item If $(Succ \: r < 2 ^k) \rightarrow \bot$, then we chose $k = Succ \: k'$ and $r = 0$. 
   \end{enumerate}

\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
