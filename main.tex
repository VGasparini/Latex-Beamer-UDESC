\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{booktabs}
\usepackage{minted}
\usepackage[portuges]{babel}

\usemintedstyle{bw}


\title[PGFTcCS]{Programação Genética Fortemente Tipada\\ com Condições Sintáticas}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{4 de Dezembro de 2017}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\section{Introdução}
\begin{frame}
\frametitle{Método básico STGP}
\begin{itemize}
    \item Programação Genética Fortemente Tipada
    \item Utiliza tipos para reduzir o espaço de busca: em um caso,
        o espaço de busca são $10^{27}$ possíveis, mas somente $10^{12}$
        são programas bem tipados.
    \item PolyGP utiliza Cálculo Lambda Tipado (sem abstração lambda).
        Recursão limitada apenas para o nome da função a ser evoluída.
    \item O polimorfismo paramétrico (Damas-Milner) tem papel fundamental: como funções podem ser aplicadas à argumentos
        de vários tipos, então há um grande reuso do material genético.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Objetivo: condições sintáticas}
O objetivo é verificar o impacto do uso de condições sintáticas
que evintam explorar programas que não são possíveis soluções.\\

Por exemplo, a função \mintinline{haskell}{if c e1 e2}
pode ter a exata mesma sub-árvore para \mintinline{haskell}{e1} e \mintinline{haskell}{e2}, ou seja,
o valor de retorno do \mintinline{haskell}{then} é o mesmo do \mintinline{haskell}{else}. Portanto, pode-se
considerar a condição \mintinline{haskell}{e1} $\not =\: $\mintinline{haskell}{e2}.\\

As condições podem ser custosas computacionalmente, pois podem necessitar comparar partes de
programas e aplica-las durante todo o processo evolucionário causaria um considerável aumento de tempo da
evolução.
\end{frame}

% \section{Representação}
% 
% \begin{frame}[fragile]
% \frametitle{Geração de programas}
%     \begin{itemize}
%         \item \small{O algoritmo de geraçao de programas funciona selecionando aleatoriamente funções primitivas (cujos os argumentos são 
% temporariamente completados com \mintinline{haskell}{ARG}s)
%             ou terminais, e aplicando as necessárias unificações e substituições de tipo.}
%     \end{itemize}
% \end{frame}
% 
% \begin{frame}[fragile]
% \frametitle{Operador de \textit{crossover}}
% O \textit{crossover} entre dois indivíduos é realizado da seguinte forma:
% \begin{enumerate}
%     \item Seleciona-se aleatoriamente um nó de aplicação no primeiro indivíduo.
%     \item Procura-se um nó para troca no segundo indivíduo que respeita os seguinte critérios: 1)
%     o tipo do retorno deve unificar com o nó selecionado no primeiro indivíduo e 2) a troca
%     das sub-árvores deve respeitar a altura máxima em ambos os indivíduos.
% \end{enumerate}
% Trocar nós utilizado a unificação (ao invés da igualdade de tipos) favorece um maior fator de recombinação
% e garante a propriedade de fechamento.
% \end{frame}
% 
% \begin{frame}[fragile]
% \frametitle{Operadores de mutação}
%     \begin{itemize}
%         \item \textit{New-sub-tree}: troca uma sub-árvore de tipo $\tau$ por uma nova (gerada aleatoriamente)
%             que não infrinja o tamanho máximo da árvore e que o tipo unifique com o tipo $\tau$.
%         \item \textit{Swap-sub-tree}: Se uma expressão tem dois argumentos cujos tipos unifiquem, 
%             ex: \mintinline{haskell}{((fun e1) e2)} tal que o tipo de \mintinline{haskell}{e1} unifica com
%             o tipo de \mintinline{haskell}{e2}, então permuta-se (\textit{swap}) a posição das sub-árvores.
%         \item Os operadores de mutação não inserem indivíduos repetidos na população.
%     \end{itemize}
% \end{frame}
% 
% \section{Algoritmo Evolucionário}
% \begin{frame}[fragile]
% \frametitle{Algoritmo Evolucionário}
% \begin{itemize}
%     \item População inicial \mintinline{haskell}{pop} de indivíduos únicos.
%     \item Os operadores de mutação e \textit{crossover} garantem a unicidade 
%         dos indivíduos durante toda a evolução.
% \end{itemize}
% Algoritmo evolucionário simplificado:
% \begin{minted}{haskell}
% evolution pop 0 = return $ pop 
% evolution pop n = do
%                   evaluedPop <- evalPopulation pop 
%                   popInter <- tourment popFitness
%                   popCrossed <- crossPop popInter
%                   popMutated <- mutationPop popCrossed
%                   r <- evolution popMutated (n - 1)
%                   return $ r
% \end{minted}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Lidando com Computações Ruins}
% \begin{itemize}
%     \item Durante a computação dos programas, duas situações ruins podem acontecer: o programa não terminar
% dentro do limite de chamadas recursivas (provavelmente um \textit{loop} sem fim) ou o programa realizar
% uma computação sem definição, como tirar a cabeça de uma lista vazia.
%     \item Em ambos os cenários 
% a computação é continuada para um valor arbitrário do tipo retorno esperado
% e é aplicado uma penalização no \textit{fitness}.
% \end{itemize}
% \begin{table}[H]
% \centering
% \begin{tabular}{l|l|l|l|l|l|}
% \cline{2-6}
%                             & Int & Bool  & Char & {[}Int{]} & {[}Char{]} \\ \hline
% \multicolumn{1}{|l|}{Valor} & 100 & False & 'z'  & {[}100{]} & {[}'z'{]}  \\ \hline
% \end{tabular}
% \caption{Valores \textit{default} para computações ruins.}
% \label{errotable}
% \end{table}
% \end{frame}

\section{Problema}
\begin{frame}[fragile]
\frametitle{Problema map}
Mapear uma função sobre uma lista:\\
\begin{minted}{haskell}
map c2i ['a'..'g'] = [0..6]
\end{minted}
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
 |T$\:=\:\{$|l::[a], |[]|::[a], f::G1->G2|$\}$|
 \end{minted}
 \begin{minted}[escapeinside=||,mathescape=true]{haskell}
 |F$\:=\:\{$|head::[a]-> a, tail::[a]->[a],
     (:)::a->[a]->[a], null::[a]->Bool,
     map::(G1->G2)->[G1]->[G2],
     if::Bool->a->a-> a, f::G1->G2|$\}$|
 \end{minted}
  \begin{minted}[escapeinside=||,mathescape=true]{haskell}
 |CS$\:=\:\{$|if c e1 e2 |\text{tal que}| e1 |$\not =$| e2,
     head l |\text{tal que}| l |$\not =$| |[]|,
     tail l |\text{tal que}| l |$\not =$| |[]| |$\}$|
 \end{minted}
\end{frame}

\begin{frame}
\frametitle{Função \textit{fitness} do problema map}
\begin{align}
\label{fitmap}
f(l,\: l') = & -2\: \cdot \mid length(l) - length(l') \mid  \nonumber\\
& + \sum_{e\: \in\: l} 10\:
\cdot (2^{dist(e,\: l')})\\
& -(10 + 2 \cdot \: length(l)) \cdot rtError \nonumber\\
& -(10 + 2 \cdot \: length(l)) \cdot reError, \nonumber
\end{align}
onde ${dist(e,\: l')}$ é $\infty$ quando $e \not \in l'$, ou caso contrário é a distância de $e$ até o
elemento de indíce $e$. $rtError$ e $reError$ representam, respectivamente, erros de computações
indefinidas e computações que excederam o limite de chamadas recursivas, e tem valor $1$ quando acontecem
e $0$ caso contrário.

Fitness normalizado!!!
\end{frame}

\section{Experimentos}
\begin{frame}
\frametitle{Parâmetros de teste do problema map}
    \begin{itemize}
        \item Populações de $250$, $500$ e $1000$ indivíduos.
        \item Com e sem as condições.
        \item Taxa de mutação de $4\%$.
        \item Taca de \textit{crossover} de $100\%$.
        \item Número de gerações de $200$.
        \item Limite de chamadas recursivas de $9$.
        \item Altura máxima das árvores de $6$.
        \item Geração da população pelo método \textit{grow}.
        \item $50$ execuções de teste.
    \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Convergência do problema map}
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{fitness.pdf}
    \caption{Média do fitness médio de 50 testes.}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Desvio Padrão da convergência}
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{erro.pdf}
    \caption{Desvio padrão do fitness médio de 50 testes.}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Boxplot da convergência}
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{box.pdf}
    \caption{Boxplot do \textit{fitness} da última geração.}
    \label{fig:boxplotmap}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Wilcoxon Pareado com cs1000}
Wilcoxon Pareado com os valores das médias do \textit{fitness} da última
geração dos $50$ testes
\begin{table}[H]
\centering
\begin{tabular}{l|l|l|l|l|l|}
\cline{2-6}
                        & nocs250             & nocs500             & nocs1000             & cs250          & cs500                \\ \hline
\multicolumn{1}{|l|}{w} & $1.11\cdot 10^{-9}$ & $1.6 \cdot 10^{-9}$ & $2.32 \cdot 10^{-9}$ & $1.18 10^{-9}$ & $1.62 \cdot 10^{-7}$ \\ \hline
\end{tabular}
\caption{Valores do teste de Wilcoxon para média dos \textit{fitness} da útlima geração.}
\label{wilcon}
\end{table}
\end{frame}

\begin{frame}[fragile]
\frametitle{Taxa de acerto}
\begin{table}[H]
\centering
\begin{tabular}{l|l|l|l|l|l|l|}
\cline{2-7}
                                     & nores250 & nores500 & nores100 & res250  & res500  & res1000   \\ \hline
\multicolumn{1}{|l|}{Acerto} & 24$\%$  & 42$\%$  & 78$\%$  & 78$\%$ & 96$\%$ & 100$\%$ \\ \hline
\end{tabular}
\caption{Taxa de acerto da solução ótima.}
\label{taxal}
\end{table}
Exemplo de resultado:
\begin{minted}[fontsize=\small]{haskell}
map f l = if null l then [] else f (head l) : map f (tail l)
\end{minted}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Avaliações de \textit{fitness} para encontrar o ótimo}
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{boxopts.pdf}
    \caption{{Boxplot do número de avaliações de \textit{fitness} para encontrar a solução
    ótima.}}
\label{fig:boxplotmap}
\end{figure}
\end{frame}

\begin{frame}
    \frametitle{Tempo médio de execução}
\begin{table}[H]
\centering
\begin{tabular}{l|l|l|l|l|l|l|}
\cline{2-7}
                            & nores250 & nores500 & nores1000 & res250 & res500 & res1000 \\ \hline
\multicolumn{1}{|l|}{Média} & 6.01s    & 13,74s   & 31.58s    & 8,28s  & 20,9s  & 51,38s  \\ \hline
\end{tabular}
\caption{Média do tempo de execução.}
\label{tem_map}
\end{table}
\end{frame}

\begin{frame}
    \frametitle{Considerações finais}
    \begin{itemize}
        \item O método utilizado foi bem sucedido para resolver o problema map.
        \item O uso das condições sintáticas teve impacto positivo na convergência, desvio padrão da convergência, taxa de acerto e número de avaliações
            de \textit{fitness} para encontrar o ótimo.
        \item Seria interessante obter informações sobre a diversidade da população.
        \item Estou implementando a evolução da função fibonacci como segundo problema.
        \item Algumas ideias: resolver problemas da maratona e evoluir funções clássicas.
    \end{itemize}
\end{frame}
\end{document}
