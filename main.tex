\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage[portuges]{babel}


\title[Um Algoritmo Verificado para Inferência de Tipos na Presença de Recursão Polimórfica]{Um Algoritmo Verificado para Inferência de Tipos na Presença de Recursão Polimórfica}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{15 de Fevereiro de 2019}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\section{Introdução}
\begin{frame}[fragile]
\frametitle{Introdução - Sistemas de Tipos}
\begin{itemize}
    \item Sistemas de tipos são regras que ditam quais expressões podem ser
associadas a quais tipos.
    \item Nas linguagens de programação, classificavam os dados para serem tratados corretamente pelo processador;
    \item passaram a ser utilizados como regras para identificar falhas na consistência
de programas
    \item Tipagem estática e dinâmica:
      \begin{itemize}
        \item Estática: atribuições de tipo não mudam em \textit{run time}; uma forma de verificação automática. 
        \item Dinâmica: atribuições de tipo \textbf{mudam} em \textit{run time}; mais permissível; mais permissível a erros. 
      \end{itemize}
      \begin{minted}{python}
      [1, 'a', objeto, [2]]
      \end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Introdução - Inferência de Tipos e Polimorfismo}
\begin{itemize}
    \item A inferência de tipos é o processo de encontrar a assinatura de tipo mais geral de um programa.
    \item Liberdade ao programador de escolher anotar ou não os tipos das funções.
    \item Polimorfismo é quando uma função pode assumir vários usos com diferentes tipos de dados. Em especial,
      o polimorfismo paramétrico é feito pela quantificação de variáveis de tipos.
      \begin{minted}{haskell}
         len :: [a] -> Int
      \end{minted}
    \item Existem situações onde a inferência de tipos é mais difícil que a verificação. Nesses casos,
      algoritmos podem rejeitar programas bem tipados.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Introdução - Recursão Polimórfica}
\begin{itemize}
    \item A recursão polimórfica acontece quando o tipo da chamada recursiva de uma função pode mudar ao longo das recursões.
\begin{minted}{haskell}
  data Seq a = Nil | Cons a (Seq (a,a)).
\end{minted}
\begin{minted}{haskell}
  len :: Seq a -> Int
  len Nil = 0
  len (Cons x s) = 1 + 2 * (len s)
\end{minted}
    \item Haskell rejeita programas com recursão polimórfica se a assinatura de tipo não for explicitamente anotada.
    \item Diversos exemplos de exemplos precisando de recursão polimórfica foram apresentados na literatura.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Introdução - Motivação e Objetivo}
\begin{itemize}
    \item O semi-algoritmo MMo proposto por (VASCONCELLOS; CAMARÃO, 2003) consegue tipar diversos casos de recursão
polimórfica.
    \item MMo não tem as suas propriedades fundamentais provadas: terminação (totalidade) e consistência (correto).
    \item \textbf{Objetivo}: investigar se o semi-algoritmo MMo tem as propriedades de totalidade e correção em relação ao seu
     sistema de tipos (especificação).
    \item A especificação em si também é um elemento de investigação.
    \item O método utilizado é a formalização do MMo e a sua especificação no assistente de provas Coq.
\end{itemize}
\end{frame}

\section{Fundamentos}

\begin{frame}
\frametitle{Fundamentos - Formalismos de Sistemas de Tipos}
\begin{itemize}
    \item Sistemas de tipos quando definidos formalmente podem garantir importantes propriedades da
    semântica de programas, como o famoso lema de Robin Milner ``Well-typed programs cannot go wrong''.
    \item Damas-Milner: polimorfismo via \textit{let}. Base para diversas linguagens de programação funcional.
    Não permite recursão polimórfica pela regra $fix$.
    \item O primeiro sistema de tipos a permitir recursão polimórfica é o Sistema-F. 
    \item Milner-Mycroft altera a regra de definições recursivas $fix$ para permitir recursões polimórficas.
\end{itemize}
\begin{center}
  \begin{minipage}{.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma, $\mintinline{haskell}{x} $:\tau \vdash$ \mintinline{haskell}{e} $:\tau$}
      \RightLabel{$(fix)$}
      \UnaryInfC{$\Gamma \vdash$ \mintinline{haskell}{fix x.e} $:\tau$}
    \end{prooftree}
    \end{minipage}
    \begin{minipage}{.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma, $\mintinline{haskell}{x} $:\sigma \vdash$ \mintinline{haskell}{e} $:\sigma$}
      \RightLabel{$(fix+)$}
      \UnaryInfC{$\Gamma \vdash$ \mintinline{haskell}{fix x.e} $:\sigma$}
    \end{prooftree}
    \end{minipage}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Fundamentos - Inferência no Milner-Mycroft}
\begin{itemize}
    \item A inferência no sistema Milner-Mycroft é equivalente ao problema da semi-unificação.
    \item A semi-unificação é uma generalização da unificação.
    \item A semi-unificação é indecidível.
      \begin{itemize}
        \item Casos decidíveis: apenas uma igualdade, qualquer aridade e no máximo uma variável livre, duas variáveis e semi-unificação acíclica.
      \end{itemize}
    \item No caso geral não há como decidir a tipabilidade (\textit{typability}) de um termo no sistema Milner-Mycroft.
    \item Se o tamanho de um tipo não é razoável ao do seu programa, é exponencial por exemplo, então esse programa é dito ter um \textit{big type} ou um
\textit{small type} caso contrário.
    \item \textit{Small types} no sistema Milner-Mycroft é decidível em tempo polinomial.
    \item Buscou-se alternativas para contornar a dificuldade deste problema.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Fundamentos - Propostas de Recursão Polimórfica}
\begin{itemize}
    \item Somente existem semi-algoritmos e algoritmos totais, mas incompletos pois rejeitam alguns programas bem tipados.
    \item O semi-algoritmo para resolver a semi-unificação apresentado em (HENGLEIN, 1993) foi utilizado na construção do semi-algoritmo W+ em (EMMS; LEIL, 1999).
      \begin{itemize}
    \item \small{Argumenta-se que assim como a inferência em Damas-Milner tem pior caso exponencial e que não acontece em situações práticas, uma diferença similar entre prática e teoria acontece na inferência do Milner-Mycroft.}
      \end{itemize}
    \item Diversas propostas para recursão polimórfica foram apresentadas na literatura com o uso
      de \textit{intersection types}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Assistentes de provas}
\begin{itemize}
    \item Assistentes de provas ou provadores interativos são programas para o desenvolvimento de provas
          formais.
    \item O núcleo de um assistente de provas é um verificador, que verifica a consistência lógica da prova.
    \item Os principais apelos para o uso de assistentes de provas são:
    \begin{itemize}
    \item a verificação mecânica é rápida e evita as falhas humanas;
    \item interatividade, permite visualizar informações sobre os estados da prova;
    \item comandos para busca de teoremas e lemas para o progresso da
      prova;
    \item automatização de provas com métodos não-deterministas;
    \item potencialização da capacidade humana de realizar provas;
    \item extração de programas verificados.
    \end{itemize}

      Assistentes de provas permitem provar coisas que não seriam realizáveis somente com papel e caneta!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Por que Coq?}
\begin{itemize}
    \item Existem dezenas de assistentes de provas: Automath, Agda, Twelf, ACL2, PVS, Minlog, Isabelle e Coq...
    \item O assistente de provas Coq tem como \textit{kernel} (núcleo) o formalismo \textit{Calculus of Inductive Constructions} (CIC), uma extensão do Cálculo Lambda Tipado conhecido como \textit{Calculus of Constructions} (CoC).
    \item CoC é classificado como um Cálculo Lambda polimórfico de ordem superior e com tipos dependentes.
    \item \textbf{Justificativa}:
      \begin{enumerate}
        \item Frequente uso de Coq para formalizar aspectos de linguagens de programação. CoqPL: uma trilha dedicada ao uso de Coq no POPL. 
        \item Projetos relevantes em Coq: CompCert é uma compilador de C; Simplicity é uma
          linguagem de programação para \textit{blockchains}; Vellvm é uma
          formalização da LLVM em Coq.
        \item Materiais didáticos disponíveis!
      \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Terminação em Coq}
\begin{itemize}
    \item Coq é uma linguagem de programação funcional total.
    \item A garantia de terminação do Coq é uma conservadora verificação sintática: recursão primitiva.
    \item Coq conta com algumas maneiras de estender o conjunto de programas que podem ser implementados:
    \begin{enumerate}
    \item Recursão bem-fundada (\textit{Well-Founded Recursion}) por meio
      de uma relação bem-fundada (\textit{Well-Founded Relation}). Os
      argumentos da chamada recursivas obedecem uma relação bem-fundada.
    \item Recursão limitada (\textit{Bounded Recursion}) através
    de um argumento, que representa o número
    de chamadas recursivas. Esse argumento contador precisa ser computado
    previamente e deve ser suficiente para que a computação finalize com o resultado
    correto.
    \item Recursão por iteração (\textit{Recursion by Iteration}) é uma
    técnica similar a recursão limitada, mas começa com a definição de
    um funcional uma definição que tem como um dos argumentos a
    função \mintinline{coq}{f} que deseja-se implementar. 
    \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Terminação em Coq}
    \begin{enumerate}
    \item Recursão sobre um predicado (\textit{Recursion on an Ad Hoc
        Predicate Section}) definido por um tipo indutivo, que serve para
    representar o domínio da função e fazer recursão estrutural sobre
    provas do princípio indutivo deste predicado.
    \item Recursão por mônada inspirada em Teoria de Domínios, cujos
    combinadores de ordem superior servem para representar até mesmo funções
    que não terminam. Uma obrigação de prova é a continuidade da
    computação na mônada.
    \item Recursão geral baseada numa mônada de um tipo co-indutivo.
    É similar ao anterior, mas utiliza os tipos co-indutivos para representar
    a noção de não terminação, com a vantagem de não ter obrigações de provas.
    \item Linguagem embutida: formalizar completamente uma linguagem
    de programação com recursão geral por meio dos tipos indutivos de Coq e,
    então, implementar os programas nesta linguagem embutida.
    \end{enumerate}
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
